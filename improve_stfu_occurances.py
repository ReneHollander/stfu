import argparse
import datetime
import json
import pathlib
import shutil
import subprocess
import random
from tqdm import tqdm


def process(clip_video_path, clip_file, improved_timestamps, output_video_path):
    clipStartS = clip_file["shut"]["startMs"] / 1000.0
    if clip_file["shut"]["durationMs"] > 1000:
        clipStartS = (clip_file["shut"]["endMs"] - 1000) / 1000.0
    clipEndS = clip_file["up"]["endMs"] / 1000.0
    if clip_file["up"]["durationMs"] > 1000:
        clipEndS = (clip_file["up"]["startMs"] + 1000) / 1000.0
    clipDurationS = clipEndS - clipStartS

    startS = clipStartS - clip_file["clipStartS"]
    endS = startS + clipDurationS

    words = [
        word for segment in improved_timestamps["segments"] for word in segment["words"]
    ]
    shut = [word for word in words if "shut" in word["word"].lower().strip()]
    up = [word for word in words if "up" in word["word"].lower().strip()]
    if not clip_file["shut"]["autogenerated"] and (len(shut) != 1 or len(up) != 1):
        tqdm.write(f"ignored: {clip_video_path} {improved_timestamps['text']}")
        return
    if len(shut) == 1 and len(up) == 1:
        shut = shut[0]
        up = up[0]
        startS = max(shut["start"] - 0.1, 0.0)
        endS = up["end"] + 0.1
        if up["end"] - up["start"] > 0.5:
            endS = min(
                up["start"] + 0.5, clip_file["clipEndS"] - clip_file["clipStartS"]
            )

    ffmpegOutput = subprocess.run(
        [
            "ffmpeg",
            "-y",
            "-ss",
            str(startS),
            "-to",
            str(endS),
            "-i",
            clip_video_path,
            "-r",
            "29.97",
            "-ar",
            "48000",
            "-af",
            "apad",
            "-c:v",
            "ffvhuff",
            "-c:a",
            "pcm_s32le",
            "-avoid_negative_ts",
            "make_zero",
            "-shortest",
            "-fflags",
            "+genpts",
            output_video_path,
        ],
        capture_output=True,
    )
    tqdm.write(f"{ffmpegOutput.args}")
    if ffmpegOutput.returncode != 0:
        tqdm.write(
            f"yt-dlp exited with {ffmpegOutput.returncode} for {clip_video_path}"
        )
        tqdm.write(f"commandline: {ffmpegOutput.args}")
        tqdm.write(ffmpegOutput.stderr.decode())
        tqdm.write(ffmpegOutput.stdout.decode())
        return None
    else:
        return (clip_file["clipStartS"] + startS, endS - startS)


def main():
    parser = argparse.ArgumentParser(description="Extract STFU occurances.")
    parser.add_argument(
        "--improved-timestamps-directory",
        type=pathlib.Path,
        default="data/improved_timestamps",
        dest="improved_timestamps_directory",
        help="Directory containing improved timestamps to extract.",
    )
    parser.add_argument(
        "--clips-directory",
        type=pathlib.Path,
        default="data/clips",
        dest="clips_directory",
        help="Directory to store the extracted clips in.",
    )
    parser.add_argument(
        "--improved-clips-directory",
        type=pathlib.Path,
        default="data/improved_clips",
        dest="improved_clips_directory",
        help="Directory to store the improved clips in.",
    )

    args = parser.parse_args()

    if args.improved_clips_directory.exists():
        shutil.rmtree(args.improved_clips_directory)

    args.improved_clips_directory.mkdir(exist_ok=True)

    clips = []

    clip_video_paths = list(args.clips_directory.glob("*.mkv"))
    for clip_video_path in tqdm(clip_video_paths, desc="Clips processed"):
        clip_file_path = clip_video_path.with_suffix(".json")
        improved_timestamps_file_path = (
            args.improved_timestamps_directory
            / clip_file_path.with_suffix(".json").name
        )
        output_video_path = args.improved_clips_directory / clip_video_path.name
        with open(clip_file_path, "r") as f:
            clip_file = json.load(f)
        with open(improved_timestamps_file_path, "r") as f:
            improved_timestamps = json.load(f)

        ret = process(clip_video_path, clip_file, improved_timestamps, output_video_path)
        if ret != None:
            clips.append((output_video_path, *ret))
    
    random.shuffle(clips)

    with open("data/all_clips.txt", "w") as all_clips:
        for filename, offset_in_original_video, duration in clips:
            video_id = filename.stem
            video_id = video_id[0:video_id.index('.')]
            all_clips.write(f"{filename};https://www.youtube.com/watch?v={video_id}&t={int(offset_in_original_video)}s\n")


if __name__ == "__main__":
    main()
